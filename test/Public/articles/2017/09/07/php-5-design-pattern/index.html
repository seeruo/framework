<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta author="">
	<meta description="">
	<meta keywords="">
	<title> PHP-设计模式 -  SeeRuo</title>
	<link rel="shortcut icon" href="/static/images/logo.ico" type="image/x-icon">
	<link rel="stylesheet" type="text/css" href="/static/css/style.css">
	<link rel="stylesheet" type="text/css" href="/static/prism/prism.css">
	<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
	<link rel="stylesheet" type="text/css" href="/static/srsearch/srsearch.css">
    <script type="text/javascript" src="/static/srsearch/srsearch.js"></script>
</head>

<body>
	<main>
		<div class="sibar">
			<div class="author_header">
				<img src="/static/images/author.jpeg">
			</div>
			<div class="logo">
				<a href="/">SeeRuo</a>
				<small>< 轻量化静态网站构建工具 ></small>
			</div>
			<div class="menu">
				<a href="/">主页</a>
				<a href="/archives">归档</a>
				<a href="/about">关于</a>
				<a href="/linker">友链</a>
			</div>
			
			<div class="links">
				<a target="_blank" href="http://seeruo.codegrids.com">Sr</a>
				<a target="_blank" href="https://github.com/seeruo"><i class="fa fa-github"></i></a>
				<a target="_blank" href="mailto:cdking95@gmail.com"><i class="fa fa-envelope-o"> </i></a>
				<a><i class="fa fa-search" id="searchDiv"></i></a>
			</div>
		</div>
		<div class="content">
			<div class="markdown-body">
				<link rel="stylesheet" type="text/css" href="/static/srwords/srwords.css">
<script type="text/javascript" src="/static/srwords/srwords.js"></script>
<style type="text/css">
    #SeeruoWords{
        margin-top: 50px;
    }
</style>
<div class="content-block">
	<section>
				<h2>PHP-设计模式</h2>
		
		<h3><a name='1.策略模式' title='1.策略模式'></a>1.策略模式</h3><blockquote>策略模式是对象的行为模式，用意是对一组算法的封装。动态的选择需要的算法并使用。</p><p>策略模式指的是程序中涉及决策控制的一种模式。策略模式功能非常强大，因为这个设计模式本身的核心思想就是面向对象编程的多形性思想。</blockquote><h5><a name='策略模式的三个角色' title='策略模式的三个角色'></a>策略模式的三个角色</h5><p>1．抽象策略角色</p><p>2．具体策略角色</p><p>3．环境角色（对抽象策略角色的引用）</p><h5><a name='实现步骤：' title='实现步骤：'></a>实现步骤：</h5><p>1．定义抽象角色类（定义好各个实现的共同抽象方法）</p><p>2．定义具体策略类（具体实现父类的共同方法）</p><p>3．定义环境角色类（私有化申明抽象角色变量，重载构造方法，执行抽象方法）</p><p>就在编程领域之外，有许多例子是关于策略模式的。例如：</p><blockquote>如果我需要在早晨从家里出发去上班，我可以有几个策略考虑：我可以乘坐地铁，乘坐公交车，走路或其它的途径。每个策略可以得到相同的结果，但是使用了不同的资源。</blockquote><pre><code class="language-php">abstract class baseAgent { //抽象策略类
    abstract function PrintPage();
}
//用于客户端是IE时调用的类（环境角色）
class ieAgent extends baseAgent {
    function PrintPage() {
        return 'IE';
    }
}
//用于客户端不是IE时调用的类（环境角色）
class otherAgent extends baseAgent {
    function PrintPage() {
        return 'not IE';
    }
}
class Browser { //具体策略角色
    public function call($object) {
            return $object-&gt;PrintPage ();
        }
    }
    $bro = new Browser ();
    echo $bro-&gt;call ( new ieAgent () );
}</code></pre><h3><a name='2.工厂模式' title='2.工厂模式'></a>2.工厂模式</h3><blockquote>工厂模式是我们最常用的实例化对象模式，是用工厂方法代替new操作的一种模式。</p><p><strong>使用工厂模式的好处是，如果你想要更改所实例化的类名等，则只需更改该工厂方法内容即可</strong>，不需逐一寻找代码中具体实例化的地方（new处）修改了。为系统结构提供灵活的动态扩展机制，减少了耦合。</blockquote><pre><code class="language-php">&lt;?php
header('Content-Type:text/html;charset=utf-8');
/**
 *简单工厂模式（静态工厂方法模式）
 */
/**
 * Interface people 人类
 */
interface  people
{
    public function  say();
}
/**
 * Class man 继承people的男人类
 */
class man implements people
{
    // 具体实现people的say方法
    public function say()
    {
        echo '我是男人&lt;br&gt;';
    }
}
/**
 * Class women 继承people的女人类
 */
class women implements people
{
    // 具体实现people的say方法
    public function say()
    {
        echo '我是女人&lt;br&gt;';
    }
}
/**
 * Class SimpleFactoty 工厂类
 */
class SimpleFactoty
{
    // 简单工厂里的静态方法-用于创建男人对象
    static function createMan()
    {
        return new man();
    }
    // 简单工厂里的静态方法-用于创建女人对象
    static function createWomen()
    {
        return new women();
    }
}
/**
 * 具体调用
 */
$man = SimpleFactoty::createMan();
$man-&gt;say();
$woman = SimpleFactoty::createWomen();
$woman-&gt;say();</code></pre><h2><a name='3.单例模式' title='3.单例模式'></a>3.单例模式</h2><blockquote>单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><p>单例模式是一种常见的设计模式，在计算机系统中，<strong>线程池、缓存、日志对象、对话框、打印机、数据库操作、显卡的驱动程序</strong>常被设计成单例。</blockquote><h5><a name='单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。' title='单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。'></a>单例模式分3种：懒汉式单例、饿汉式单例、登记式单例。</h5><pre><code>    
单例模式有以下3个特点：
1．只能有一个实例。
2．必须自行创建这个实例。
3．必须给其他对象提供这一实例。
那么为什么要使用PHP单例模式？
</code></pre><p>PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。</p><pre><code class="language-php">class Single {
    private $name;//声明一个私有的实例变量
    private function __construct(){//声明私有构造方法为了防止外部代码使用new来创建对象。
    }
    static public $instance;//声明一个静态变量（保存在类中唯一的一个实例）
    static public function getinstance(){//声明一个getinstance()静态方法，用于检测是否有实例对象
        if(!self::$instance) self::$instance = new self();
            return self::$instance;
    }
    public function setname($n){
        $this-&gt;name = $n;
    }
    public function getname(){
        return $this-&gt;name;
    }
}
$oa = Single::getinstance();
$ob = Single::getinstance();
$oa-&gt;setname('hello world');
$ob-&gt;setname('good morning');
echo $oa-&gt;getname();//good morning
echo $ob-&gt;getname();//good morning</code></pre><h2><a name='4.注册模式' title='4.注册模式'></a>4.注册模式</h2><blockquote>注册模式，解决全局共享和交换对象。已经创建好的对象，挂在到某个全局可以使用的数组上，在需要使用的时候，直接从该数组上获取即可。将对象注册到全局的树上。任何地方直接去访问。</blockquote><pre><code class="language-php">class Register
{
    protected static  $objects;
    function set($alias,$object)//将对象注册到全局的树上
    {
        self::$objects[$alias]=$object;//将对象放到树上
    }
    static function get($name){
        return self::$objects[$name];//获取某个注册到树上的对象
    }
    function _unset($alias)
　　{
        unset(self::$objects[$alias]);//移除某个注册到树上的对象。
    }
}
class Class1
{
    public $name = 'danier';
}
class Class2
{
    public $name = 'jack';
}

$app = new Register();
$app-&gt;set('dan', new Class1);
$app-&gt;set('jack', new Class2);

$ss = $app-&gt;get('jack')-&gt;name;
print_r($ss);</code></pre><h2><a name='适配器模式' title='适配器模式'></a>适配器模式</h2><blockquote>将各种截然不同的函数接口封装成统一的API。 </p><p>PHP中的数据库操作有MySQL,MySQLi,PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。类似的场景还有cache适配器，可以将memcache,redis,file,apc等不同的缓存函数，统一成一致。</p><p>首先定义一个接口(有几个方法，以及相应的参数)。然后，有几种不同的情况，就写几个类实现该接口。将完成相似功能的函数，统一成一致的方法。</blockquote><h5><a name='接口 IDatabase' title='接口 IDatabase'></a>接口 IDatabase</h5><pre><code class="language-php">namespace IMooc;
interface IDatabase
{
    function connect($host, $user, $passwd, $dbname);
    function query($sql);
    function close();
}</code></pre><h5><a name='class MySQL' title='class MySQL'></a>class MySQL</h5><pre><code class="language-php">namespace IMooc\Database;
use IMooc\IDatabase;
class MySQL implements IDatabase
{
    protected $conn;
        function connect($host, $user, $passwd, $dbname)
        {
            $conn = mysql_connect($host, $user, $passwd);
            mysql_select_db($dbname, $conn);
            $this-&gt;conn = $conn;
    }
    function query($sql)
        {
            $res = mysql_query($sql, $this-&gt;conn);
            return $res;
    }
    function close()
    {
        mysql_close($this-&gt;conn);
    }
}</code></pre><h5><a name='class MySQLi' title='class MySQLi'></a>class MySQLi</h5><pre><code class="language-php">namespace IMooc\Database;
use IMooc\IDatabase;
class MySQLi implements IDatabase
{
    protected $conn;
    function connect($host, $user, $passwd, $dbname)
    {
        $conn = mysqli_connect($host, $user, $passwd, $dbname);
        $this-&gt;conn = $conn;
    }
    function query($sql)
    {
        return mysqli_query($this-&gt;conn, $sql);
    }
    function close()
    {
        mysqli_close($this-&gt;conn);
    }
}</code></pre><h5><a name='使用' title='使用'></a>使用</h5><pre><code class="language-php">namespace Model;
use IMoocIMooc\Database\MySQL;
use IMoocIMooc\Database\MySQLi;
class Model
{
    private $db;
    public function __construct($mod='Mysql'){
        if( $mod == 'Mysql' ) {
            $this-&gt;db = new MySQL();
        }else if($mod == 'MySQLi') {
            $this-&gt;db = new MySQLi();
        }
    }
    public function get($sql){
        $this-&gt;db-&gt;query($sql);
    }
}</code></pre><h2><a name='5.观察者模式' title='5.观察者模式'></a>5.观察者模式</h2><blockquote>1：观察者模式(Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。 </p><p>2：场景:一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。 </p><p>3：观察者模式实现了低耦合，非侵入式的通知与更新机制。 <br>定义一个事件触发抽象类。</blockquote>

				<blockquote class="author_block">
			<ul>
				<li>本文作者: Danier(左浪)</li>
				<li>本文链接: http://www.example.com/articles/2017/09/07/php-5-design-pattern</li>
				<li>版权声明: 本博客所有文章除特别声明外，转载请注明出处！</li>
			</ul>
		</blockquote>
		<div id="SeeruoWords"></div>
		
	</section>
	<script type="text/javascript">
		document.querySelector('body').onload= function () {
			SrWords('#SeeruoWords',{
	            // apiBase:"http://api.codegrids.com/api"
	        })
		}
	</script>
</div>
			</div>
		</div>
	</main>
	<script src="/static/prism/prism.js"></script>
	<script type="text/javascript">
		SrSearch('#searchDiv',{
            // apiBase:"http://www.codegrids.com/articles"
        })
	</script>
</body>
</html>